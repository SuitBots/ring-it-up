#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     ir,             sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ir1,            sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          HandL,         tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,          HandR,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     ML,            tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     MR,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     ScissorL1,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     ScissorR1,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     ScissorL2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     ScissorR2,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    HandLR,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_6,    hand_vertical,        tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

void initializeRobot()  {
	nMotorEncoder[HandL] = 0;
}

void syncMotors (char Motor1, char Motor2) {
	while (nMotorEncoder[Motor1] > nMotorEncoder[Motor2])
		motor[Motor2] += 1;
	while (nMotorEncoder[Motor1] < nMotorEncoder[Motor2])
		motor[Motor1] += 1;
}

void SetMotor(char name, int x) {             // makes a void with argument like in SetServo
	motor[name] = x;                            // The motor will be set to x (specified when the function is called
}


int J1X1()  { return joystick.joy1_x1; }       // These lines make pretty variables for the joysticks
int J1X2()  { return joystick.joy1_x2; }       // J is which logitech controller is being used
int J1Y1()  { return joystick.joy1_y1; }       // X or Y is the axis on which the compiler will read values
int J1Y2()  { return joystick.joy1_y2; }       // 1 or 2 is which joystick values will be read from
int J2X1()  { return joystick.joy2_x1; }
int J2X2()  { return joystick.joy2_x2; }
int J2Y1()  { return joystick.joy2_y1; }
int J2Y2()  { return joystick.joy2_y2; }



void drive() {
	/*int crawlRate = 25;  // adjust this for a different crawl rate
	int leftMotorVal = (J1Y2() + J1X2());
	int rightMotorVal = (J1Y2() - J1X2());
	int expLeftMotorVal;
	int expRightMotorVal;
	if (leftMotorVal < 0){
		expLeftMotorVal = pow(10, ((((abs(leftMotorVal) * 2) / 255)))) -1;
		expLeftMotorVal *= -1;
	}
	else expLeftMotorVal = pow(10, ((((leftMotorVal * 2) / 255)))) - 1;
	if (rightMotorVal < 0)
	expRightMotorVal = pow(10, ((((abs(leftMotorVal) * 2) / 255)))) - 1;

	if (joy1Btn(6)){ // Right Button
		SetMotor(ML, expLeftMotorVal / crawlRate);  // crawl rate means that it'll go slowly if the driver
		SetMotor(MR, expRightMotorVal / crawlRate);  // pushes a button
	} else {
		SetMotor(ML, expLeftMotorVal);
		SetMotor(MR, expRightMotorVal);
	}*/
	SetMotor(ML, (J1Y2() - J1X2()));
	SetMotor(MR, (J1Y2() + J1X2()));
}


void operateLR() {
	int left = 0;
	int right = 256;
	int stopped = 127;

	if (joy2Btn(5)) { // Left Button
		servo[HandLR] = left;
	}
	else if (joy2Btn(6)) { // Right Button
		servo[HandLR] = right;
	}
	else {
		servo[HandLR] = stopped;
	}
}

void limit_hand_motion() {
	int distance_limit = 180; //placeholder

	if (joy2Btn(8)) // Select Button
		nMotorEncoder[HandL] = 0;
	if (! joy2Btn(0)) { // X Button
		if (nMotorEncoder[HandL] > distance_limit
			  || nMotorEncoder[HandL] < distance_limit * -1)
			motor[HandL] = 0;
	}
}


void HandOpe(char name, int x) {
	servo[name] = x;
}

void operate_scissor() {
	SetMotor(ScissorL1, -J2Y1());
	SetMotor(ScissorR1, -J2Y1());
	SetMotor(ScissorL2, -J2Y1());
	SetMotor(ScissorR2, -J2Y1());

	if (joy2Btn(3))	{ // B button
		SetMotor(ScissorL1, 90);
		SetMotor(ScissorL2, 90);
	}

	if (joy2Btn(4)) { // Y button
		SetMotor(ScissorR1, 90);
		SetMotor(ScissorR2, 90);
	}
}

void operate_hand_vertical() {
	if (joystick.joy2_TopHat == 0) // up on D-pad
		servo[hand_vertical] = 255 / 2; //tune it

	if (joystick.joy2_TopHat == 2) // right on D-pad
		servo[hand_vertical] = 255 / 4; //tune it

	if (joystick.joy2_TopHat == 4) // down on D-pad
		servo[hand_vertical] = 0; //tune it
}

/*void operate_fork_assembly() {

	while (joy2Btn(6)) // left trigger
	{
		motor[fork_prop] = 100; //tune it
	}
	while (joy2Btn(7))
	{
		motor[fork_prop] = -100;
	}
}
*/

task movement()
{
	drive();
	operateLR();
}


task accessories()
{
	nSyncedMotors = synchAB;  //IMPORTANT (to Hunter): the hand motors are plugged in to A and B (not B and C)
	nSyncedTurnRatio = 100;
	nMotorEncoder[HandL] = 0;

	operateLR();

	int hand_ritard = 2.75;

	SetMotor(HandL, -J2Y2() / hand_ritard);
	//limit_hand_motion();

	operate_scissor();
	operate_hand_vertical();
	//operate_fork_assembly();
}


task main()
{
	initializeRobot();

	waitForStart();

	while (true) {
		StartTask(movement);
		StartTask(accessories);
		getJoystickSettings(joystick);
	}
}
