#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,          HandL,         tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,          HandR,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          Scoop,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     ML,            tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     MR,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     ScissorL1,     tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     ScissorR1,     tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     ScissorL2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     ScissorR2,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_5,    HandLR,               tServoContinuousRotation)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

void initializeRobot()  {
	nMotorEncoder[ScissorL1] = 0;  //This may be the solution to our problems
	nMotorEncoder[ScissorR1] = 0;
	//servo[HandLR] = 127;
	//servo[HandOp] = 0;
}

void syncMotors (char Motor1, char Motor2) {
	while (nMotorEncoder[Motor1] > nMotorEncoder[Motor2])
		motor[Motor2] += 1;
	while (nMotorEncoder[Motor1] < nMotorEncoder[Motor2])
		motor[Motor1] += 1;
}

void SetMotor(char name, int x) {             //makes a void with argument like in SetServo
	motor[name] = x;                            //The motor will be set to x (specified when the function is called
}


int J1X1 = joystick.joy1_x1;       //These lines make pretty variables for the joysticks
int J1X2 = joystick.joy1_x2;       //J is which logitech controller is being used
int J1Y1 = joystick.joy1_y1;       //X or Y blah is which direction the joystick will go
int J1Y2 = joystick.joy1_y2;
int J2X1 = joystick.joy2_x1;
int J2X2 = joystick.joy2_x2;
int J2Y1 = joystick.joy2_y1;
int J2Y2 = joystick.joy2_y2;



void drive() {
	int crawlRate = 25;  // adjust this for a different crawl rate
	if (joy1Btn(6)){
		SetMotor(ML, (J1Y2 / crawlRate + J1X2 / crawlRate));  // crawl rate means that it'll go slowly if the driver
		SetMotor(MR, (J1Y2 / crawlRate - J1X2 / crawlRate));  // pushes a button
	} else {
		SetMotor(ML, (J1Y2 + J1X2));
		SetMotor(MR, (J1Y2 - J1X2));
	}
}

//void operateHand()  {

//	if (joy2Btn(01))
//	{
//		servo[HandOp] = 256;
//	}
//	else if (joy2Btn(02))
//	{
//		servo[HandOp] = 0;
//	}

//}

void operateLR() {

	if (joy2Btn(5)) {
		servo[HandLR] = 0;
	}
	else if (joy2Btn(6)) {
		servo[HandLR] = 256;
	}
	else {
		servo[HandLR] = 127;
	}
}


void HandOpe(char name, int x) {
	servo[name] = x;
}

//void RotateHand(int joy) {
//	SetMotor(HandL, joy);
//	while (true) {
//		nMotorEncoderTarget[HandL] = 1;
//		nMotorEncoderTarget[HandL] = -1;
//	}
//}

task Player1()
{
	drive();
	operateLR();
	//operateHand();
	//if (joy1Btn(1))
	//SetMotor(Fork, 75);
}


task Player2()
{
	nSyncedMotors = synchAB;  //IMPORTANT (to Hunter): the hand motors are plugged in to A and B (not B and C)
	nSyncedTurnRatio = 100;
	//syncMotors(ScissorL, ScissorR);  // @TODO: Test if this works

	//syncMotors(ScissorL1, ScissorL2);
	//syncMotors(ScissorR1, ScissorR2);
	operateLR();
	//HandleHandLeftRight();
	//HandleHandOpenClose();
	SetMotor(HandL, -J2Y2 / 2.75);
	//RotateHand(J2Y1());
	SetMotor(ScissorL1, -J2Y1);
	SetMotor(ScissorR1, -J2Y1);
	SetMotor(ScissorL2, -J2Y1);
	SetMotor(ScissorR2, -J2Y1);

	if (joy2Btn(3))	{ 		//Both players have to push whatever button and hold it to adjust the motors
		SetMotor(ScissorL1, 75);
		SetMotor(ScissorL2, 75);
	}

	if (joy2Btn(4)) {
		SetMotor(ScissorR1, 75);
		SetMotor(ScissorR2, 75);
	}

}


task main()
{
	initializeRobot();  // @TODO: Does this do anything mechanical?

	waitForStart();   // wait for start of tele-op phase

	while (true)
	{
		StartTask(Player1);
		StartTask(Player2);
	}
}
