//
// Holonomic_TeleOp.c
//
// Copyright (c) 2013 Suit Bots 4628
//

#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     DriveF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     DriveB,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     DriveL,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     DriveR,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Autonomous_Base.h"

int J1X1()  { return joystick.joy1_x1; }       // These lines make pretty variables for the joysticks
int J1X2()  { return joystick.joy1_x2; }       // J is which logitech controller is being used
int J1Y1()  { return joystick.joy1_y1; }       // X or Y is the axis on which the compiler will read values
int J1Y2()  { return joystick.joy1_y2; }       // 1 or 2 is which joystick values will be read from
int J2X1()  { return joystick.joy2_x1; }
int J2X2()  { return joystick.joy2_x2; }
int J2Y1()  { return joystick.joy2_y1; }
int J2Y2()  { return joystick.joy2_y2; }

void drive_right_joy() {
	motor[DriveB] = motor[DriveL] = (J1Y2() + J1X2());
	motor[DriveR] = motor[DriveF] = (J1Y2() - J1Y2());
}

void drive_left_joy() {
	motor[DriveL] = motor[DriveB] = motor[DriveR] = motor[DriveF] = J1X1();
}

task drive() {
	drive_right_joy();
	drive_left_joy();
}

task main()
{
	StartTask(drive);


}
