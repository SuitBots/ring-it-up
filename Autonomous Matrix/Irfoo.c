#pragma config(Sensor, S3,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S4,     ir2,            sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//
// RoboSeek.c - This program uses the HiTechnic IR Seeker V2
// sensor to follow an IR source.  This program requires the
// HTIRS2-driver.h driver provided with RobotC.
//
// You can copy the "drivers" subdirectory and place it
// in the same directory as this source file. if you do,
// you can use the following #include statement to specify
// the path to the driver.
//#include "drivers/HTIRS2-driver.h"
// if you use the "drivers/HTIRS2-driver.h" line,
// then you should comment out the following line.
#include "hitechnic-irseeker-v2.h"
// main task
task main ()
{
	int _dirAC1 = 0;
	int _dirAC2 = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;
	int acS12, acS22, acS32, acS42, acS52 = 0;
	int maxSig = 0;    // the max signal strength from the seeker.
	int maxSig2 = 0;

	// we are going to set DSP mode to 1200 Hz.
	tHTIRS2DSPMode _mode = DSP_1200;
	// attempt to set to DSP mode.
	if (HTIRS2setDSPMode(HTIRS2, _mode) == 0 || HTIRS2setDSPMode(ir2, _mode) == 0)
	{
		// unsuccessful at setting the mode.
		// display error message.
		eraseDisplay();
		nxtDisplayCenteredTextLine(0, "ERROR!");
		nxtDisplayCenteredTextLine(2, "Init failed!");
		nxtDisplayCenteredTextLine(3, "Connect sensor");
		nxtDisplayCenteredTextLine(4, "to Ports 1 and 4.");
		// make a noise to get their attention.
		PlaySound(soundBeepBeep);
		// wait so user can read message, then leave main task.
		wait10Msec(300);
		return;
	}

	eraseDisplay();
	// loop continuously and read from the sensor.
	while(true)
	{
		// read the current modulated signal direction
		_dirAC1 = HTIRS2readACDir(HTIRS2);
		_dirAC2 = HTIRS2readACDir(ir2);
		if (_dirAC1 < 0)
		{
			// error! - write to debug stream and then break.
			writeDebugStreamLine("Read dir ERROR!");
			break;
		}
		if (_dirAC2 < 0)
		{
			// error! - write to debug stream and then break.
			writeDebugStreamLine("Read dir ERROR!");
			break;
		}
		// Get the AC signal strength values.
		if (!HTIRS2readAllACStrength(HTIRS2, acS1, acS2, acS3, acS4, acS5 ))
		{
			// error! - write to debug stream and then break.
			writeDebugStreamLine("Read sig ERROR!");
			break;
			}  else {
			// find the max signal strength of all detectors.
		maxSig = (acS1 > acS2) ? acS1 : acS2;
		maxSig = (maxSig > acS3) ? maxSig : acS3;
		maxSig = (maxSig > acS4) ? maxSig : acS4;
		maxSig = (maxSig > acS5) ? maxSig : acS5;
		}
		if (!HTIRS2readAllACStrength(ir2, acS12, acS22, acS32, acS42, acS52 ))
		{
			// error! - write to debug stream and then break.
			writeDebugStreamLine("Read sig ERROR!");
			break;
			}  else {
			// find the max signal strength of all detectors.
		maxSig2 = (acS12 > acS22) ? acS12 : acS22;
		maxSig2 = (maxSig2 > acS32) ? maxSig2 : acS32;
		maxSig2 = (maxSig2 > acS42) ? maxSig2 : acS42;
		maxSig2 = (maxSig2 > acS52) ? maxSig2 : acS52;
		}

		// display info
		nxtDisplayCenteredTextLine(1, "DirL = %d", _dirAC1);
		nxtDisplayCenteredTextLine(4, "DirR = %d", _dirAC2);
		nxtDisplayCenteredTextLine(2, "SigL = %d", maxSig);
		nxtDisplayCenteredTextLine(5, "SigR = %d", maxSig2);
		// figure out which direction to go...
		// a value of zero means the signal is not found.
		// 1 corresponds to the far left (approx. 8 o'clock position).
		// 5 corresponds to straight ahead.
		// 9 corresponds to far right.
		// first translate directional index so 0 is straight ahead.
		// wait a little before resuming.
		wait10Msec(2);
	}
}
