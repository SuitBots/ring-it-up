#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     ir,             sensorI2CCustom)
#pragma config(Sensor, S4,     ir1,            sensorI2CCustom)
#pragma config(Motor,  motorA,          HandL,         tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,          HandR,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          Scoop,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     ML,            tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     MR,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     ScissorL1,     tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     ScissorR1,     tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     ScissorL2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     ScissorR2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     fork,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    HandLR,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Autonomous_Base.h"

void initializeRobot() {
  return;
}

/// @returns 0 for the left column, 1 for middle, 2 for right
peg_t FindTheColumnThatTheIRBeaconIsOn() {
  peg_t peg = dondePeg(ir, ir1);
  return peg;
}

void DeadReckoningDriveForwardCM(long amount) {
  const float SCALE_FACTOR = 68.8973;
  bool direction = amount > 0;
  amount = abs(amount);
  forward(100, amount * SCALE_FACTOR, direction, ML, MR);
}

void TurnLeftThisManyDegrees (int degrees) {
  const float SCALE_FACTOR = 37;
  int abs_degrees = abs(degrees);
  swingTurn(100, abs_degrees * SCALE_FACTOR, degrees > 0, ML, MR);
}

void GoForward (const long cm) { DeadReckoningDriveForward (cm); }
void GoBackwards (const long cm) { DeadReckoningDriveForward (-cm); }
void TurnLeft (const int degrees) { TurnLeftThisManyDegrees (degrees); }
void TurnRight (const int degrees) { TurnLeftThisManyDegrees (-degrees); }

// Raises the scissor lift to the correct level for peg 1
// Also tilts the hand forward
void RaiseTheScissorToPeg1Level ()
{ // todo: find how many turns it takes and use a constant
  const int scissor_travel_amt = 300;
  forward(100, scissor_travel_amt, true, ScissorL1, ScissorR1);
  forward(100, scissor_Travel_amt, true, ScissorL2, ScissorR2);
}

// Lowers the scissor to the level where they need to be to grab a ring
void DropScissorLift ()
{ // todo: find how many turns it takes and use a constant
  const int scissor_travel_amt = 300;
  forward(100, scissor_travel_amt, false, ScissorL1, ScissorR1);
  forward(100, scissor_Travel_amt, false, ScissorL2, ScissorR2);
}

// Returns true when we're close enough to the peg to stop
bool ProximitySensorSaysStop () {
  int PROXIMITY_POWER_CUTOFF = 60;
  int left_power = IRmax_sig(ir);
  int right_power = IRmax_sig(ir1);

  if (left_power == 0
      || right_power == 0
      || (left_power < PROXIMITY_POWER_CUTOFF
          && right_power < PROXIMITY_POWER_CUTOFF))
    writeDebugStreamLine("STOP");

  return left_power == 0
    || right_power == 0
    || (left_power < PROXIMITY_POWER_CUTOFF
        && right_power < PROXIMITY_POWER_CUTOFF);
}

// Uses IR Sensors to make sure we're lined up left-to-right
// Uses a proximity sensor to know when to stop
void GuidedDriveForward () {
  int DEFAULT_MOTOR_SPEED = 100;
  int POWER_DIFF_THRESHOLD = 10;
  while(! ProximitySensorSaysStop ()) {
    int left_power = IRmax_sig(ir);
    int right_power = IRmax_sig(ir1);
    int left_motor_speed = DEFAULT_MOTOR_SPEED;
    int right_motor_speed = DEFAULT_MOTOR_SPEED;

    int power_diff = left_power - right_power;
    if(abs(power_diff) > POWER_DIFF_THRESHOLD) {
      left_motor_speed -= power_diff;
      right_motor_speed += power_diff;
    }

    motor[ML] = left_motor_speed;
    motor[MR] = right_motor_speed;
  }
}

void DriveToPegLeft ()
{ GoForward (150.0);
  TurnRight (45.0);
  // GoForward (30.0);
}

void DriveToPegMiddle ()
{ GoForward (83.0);
  TurnRight (45.0);
  // GoForward (20.0);
}

void DriveToPegRight ()
{ GoForward (65.0);
  TurnRight (20.0);
}

void DriveToPeg (peg_t column)
{ if (LEFT == column)
    DriveToPegLeft ();
  else if (MIDDLE == column)
    DriveToPegMiddle ();
  else if (RIGHT == column)
    DriveToPegRight ();
}

void DriveToDispensor (peg_t column)
{ // todo
}

void IRAutonomous () {
  peg_t column = FindTheColumnThatTheIRBeaconIsOn();
  DriveToPeg (column);
  RaiseTheScissorToPeg1Level ();
  GuidedDriveForward ();
  /* TODO: Calibrate to this point and then move forward
    DropScissorLift ();
    DriveToDispensor (column);
  */
}

task main() {
  initializeRobot();
  waitForStart();
  IRAutonomous();
}
