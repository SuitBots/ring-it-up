#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     ir,             sensorI2CCustom)
#pragma config(Sensor, S4,     ir1,            sensorI2CCustom)
#pragma config(Motor,  motorA,          HandL,         tmotorNXT, openLoop, reversed, encoder)
#pragma config(Motor,  motorB,          HandR,         tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     ML,            tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     MR,            tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     ScissorL1,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     ScissorR1,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     ScissorL2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     ScissorR2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     fork,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_5,    HandLR,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S1_C3_6,    hand_vertical,        tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "Autonomous_Base.h"

void initializeRobot() {
	servo[hand_vertical] = 60;
}

/// @returns 0 for the left column, 1 for middle, 2 for right
peg_t FindTheColumnThatTheIRBeaconIsOn() {
	peg_t peg = dondePeg(ir, ir1);
	return peg;
}

void DeadReckoningDriveForwardCM(long amount) {
	float scale_factor = 68.8973;
	bool direction = amount > 0;
	amount = abs(amount);
	//motor[ML] = motor[MR] = 100;
	//wait1Msec(1000);
	forward(100, amount * scale_factor, direction, ML, MR);
}

/// @returns the amount we should drive forward in phase 1 for each column
long InitialForward(peg_t column) {
	if (column == LEFT) {
		return 129; // tune it
	}
	if (column == MIDDLE) {
		return 45; // tune it
	}
	if (column == RIGHT) {
		return 5; // tune it
	}
	else return -5; // tune it
}

/// @returns the amount we should back up from our column to get to the dispensor
long BackUpAmount (peg_t column) {
	if (column == LEFT) {
		return -10; // tune it
	}
	if (column == MIDDLE) {
		return -10; // tune it
	}
	if (column == RIGHT) {
		return -10; // tune it
	}
	else return -10; // tune it
}

long second_distance(peg_t column) {
	if (column == LEFT) {
		return 60; // tune it
	}
	if (column == MIDDLE) {
		return 115; // tune it
	}
	if (column == RIGHT) {
		return 105; // tune it
	}
	else return 110; // tune it
}

int FirstTurn(peg_t column) {
	if (column == LEFT)
		return 25;

	if (column == MIDDLE)
		return 24;

	if (column == RIGHT)
		return 50;

	else return 0;
}

void MoveHand (bool direction) {
	if (direction)
		servoTarget[hand_vertical] = 180;
	if (! direction)
		servoTarget[hand_vertical] = 60;
}

void TurnLeftThisManyDegrees (int degrees) {
	float scale_factor = 75;
	int abs_degrees = abs(degrees);
	swingTurn(100, abs_degrees * scale_factor, degrees > 0, ML, MR);
}

void RightColumnSpecialCase() {
	DeadReckoningDriveForwardCM(34);
	TurnLeftThisManyDegrees(-24);
	//TurnLeftThisManyDegrees(0);
}

// Raises the scissor lift to the correct level for peg 1
// Also tilts the hand forward
void RaiseTheScissorToPeg1Level () {
	forward(100, 300, true, ScissorL1, ScissorR1); //tune the 300000 in both of these
	forward(100, 300, true, ScissorL2, ScissorR2);
}

void DropScissorLift () {
	//forward(100, 300, true, ScissorL1, ScissorR1); //tune the 300000 in both of these
	//forward(100, 300, true, ScissorL2, ScissorR2);
	while (nMotorEncoder[ScissorL1] < 300
		     && nMotorEncoder[ScissorR1] < 300) {
		motor[ScissorL1] = motor[ScissorL2] = motor[ScissorR1] = motor[ScissorR2] = 100;
	}
}

// Returns true when we're close enough to the peg to stop
bool ProximitySensorSaysStop () {
	int PROXIMITY_POWER_CUTOFF = 30;
	int left_power = IRmax_sig(ir);
	int right_power = IRmax_sig(ir1);

	if (left_power == 0
		|| right_power == 0
		|| (left_power < PROXIMITY_POWER_CUTOFF
		   && right_power < PROXIMITY_POWER_CUTOFF))
		writeDebugStreamLine("STOP");

	return left_power == 0
		|| right_power == 0
		|| (left_power < PROXIMITY_POWER_CUTOFF
		    && right_power < PROXIMITY_POWER_CUTOFF);
}


void MoveForwardWithSpeeds(int left, int right) {
	motor[ML] = left;
	motor[MR] = right;
}

// Uses IR Sensors to make sure we're lined up left-to-right
// Uses a proximity sensor to know when to stop
void GuidedDriveForward () {
	int DEFAULT_MOTOR_SPEED = 100;
	int POWER_DIFF_THRESHOLD = 10;
	while(! ProximitySensorSaysStop ()) {
		int left_power = IRmax_sig(ir);
		int right_power = IRmax_sig(ir1);
		int left_motor_speed = DEFAULT_MOTOR_SPEED;
		int right_motor_speed = DEFAULT_MOTOR_SPEED;

		int power_diff = left_power - right_power;
		if(abs(power_diff) > POWER_DIFF_THRESHOLD) {
			left_motor_speed -= power_diff;
			right_motor_speed += power_diff;
		}

		MoveForwardWithSpeeds(- abs(left_motor_speed), - abs(right_motor_speed));
	}
}

void IRAutonomous () {
	const peg_t column = FindTheColumnThatTheIRBeaconIsOn();
  DeadReckoningDriveForwardCM(InitialForward(column));
	TurnLeftThisManyDegrees(FirstTurn(column));
	if (column == RIGHT)
		RightColumnSpecialCase();
	//RaiseTheScissorToPeg1Level ();
	DeadReckoningDriveForwardCM(second_distance(column));
	servo[hand_vertical] = 180;
	wait10Msec(100);
	DeadReckoningDriveForwardCM(BackUpAmount(column));
	//TurnLeftThisManyDegrees(135.0);
	//DeadReckoningDriveForward(ThirdForward(column));
}

task main() {
	initializeRobot();
	waitForStart();
	wait10Msec(1);
	IRAutonomous();
}
