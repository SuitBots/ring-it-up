//
// IRAutonomous.c
//
// Copyright (c) 2013 Suit Bots 4628
//

#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     ir1,            sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     ir2,            sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     proximity,      sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     ML,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     MR,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     ScissorL1,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     ScissorR1,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     ScissorL2,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     ScissorR2,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    HandOp,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "hitechnic-irseeker-v2.h"
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-eopd.h"
#include "Autonomous_Base.h"

int irDirection (char sensor) {
	int _dirAC = 0;
	int acS1, acS2, acS3, acS4, acS5 = 0;


	tHTIRS2DSPMode _mode = DSP_1200;

	if (HTIRS2setDSPMode(sensor, _mode) == 0) {

		eraseDisplay();
		nxtDisplayCenteredTextLine(0, "ERROR!");
		nxtDisplayCenteredTextLine(2, "Init failed!");
		nxtDisplayCenteredTextLine(3, "Connect sensor properly");


		PlaySound(soundBeepBeep);

		wait10Msec(300);
		return 0;
	}

	_dirAC = HTIRS2readACDir(sensor);

	if (_dirAC < 0) {
		writeDebugStreamLine("Read dir ERROR!");
		return 0;
	}

	if (!HTIRS2readAllACStrength(sensor, acS1, acS2, acS3, acS4, acS5 )) {
		writeDebugStreamLine("Read sig ERROR!");
		return 0;
	}
	return _dirAC;
}

int reversed_ir_sensor(int sensorVal) {
	int x = sensorVal * -1 + 10;
	return x;
}

int proximityDistance() {

	int _processed = 0;

	HTEOPDsetShortRange(proximity);
	_processed = HTEOPDreadProcessed(proximity);

	return _processed;
}

task main () {
	while ((irDirection(ir1) != irDirection(ir2)) &&
		(irDirection(ir1) == 7)) { // 7 is a placeholder
		motor[ML] = 50 + 30 * irDirection(ir1);
		motor[MR] = 50 + 30 * reversed_ir_sensor(irDirection(ir2));
		// This might be better done with PID control, though I fear adding that will further
		// smoke our drive motors (that is, only if the other team blocks us)
		//
		// APIs for PID control:
		motorPWMLevel[ML] = 50;

	}
	while (true) {
		if (proximityDistance() != 7) { // 7 is a placeholder
			while (nMotorEncoder[ML] > -400 && nMotorEncoder[MR] > -400) {
				motor[ML] = -75;
				motor[MR] = -75;
			}
			nMotorEncoder[ML] = 0;
			nMotorEncoder[MR] = 0;
			while (nMotorEncoder[ML] < 400 && nMotorEncoder[MR] < 400) {
				motor[ML] = 75;
				motor[MR] = 75;
			}
			// We should check the tendancies of this and replace the above step with turning
			// in the direction opposite the tendancy.
			// We should also test the proximity sensor to see if it has any omnidirectionality
		}
	}
}
